<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pool</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #0b1924, #02070b 70%);
      color: #f4f4f4;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }

    h1 {
      margin-bottom: 6px;
    }

    #topBar {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .modeBtn {
      padding: 6px 12px;
      border-radius: 999px;
      border: none;
      background: #f9d675;
      color: #111;
      cursor: pointer;
      font-size: 14px;
      box-shadow: 0 3px 0 #8a6220;
    }

    .modeBtn.active {
      background: #ffd34f;
      box-shadow: 0 3px 0 #b07a1f;
    }

    #scoreDisplay, #turnDisplay {
      font-size: 14px;
      opacity: 0.9;
    }

    #poolCanvas {
      background: #116b3a;
      border-radius: 16px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.6);
      border: 18px solid #5b3a1a;
      display: block;
    }

    #hint {
      margin-top: 12px;
      font-size: 13px;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <h1>Pool</h1>

  <div id="topBar">
    <button class="modeBtn active" id="player1Btn">1 Player</button>
    <button class="modeBtn" id="vsAiBtn">Vs AI</button>
    <span id="scoreDisplay">Sunk balls: 0</span>
    <span id="turnDisplay">Turn: Player</span>
  </div>

  <canvas id="poolCanvas" width="800" height="400"></canvas>

  <span id="hint">Click and drag from the cue ball to pull back and shoot.</span>

  <script>
    const canvas = document.getElementById("poolCanvas");
    const ctx = canvas.getContext("2d");

    const width = canvas.width;
    const height = canvas.height;

    const BALL_RADIUS = 10;
    const FRICTION = 0.992;
    const MIN_SPEED = 0.02;

    let balls = [];
    let cueBall;
    let isAiming = false;
    let mousePos = { x: 0, y: 0 };
    let sunkCount = 0;

    const scoreDisplay = document.getElementById("scoreDisplay");
    const turnDisplay = document.getElementById("turnDisplay");

    const player1Btn = document.getElementById("player1Btn");
    const vsAiBtn = document.getElementById("vsAiBtn");

    let vsAI = false;
    let currentTurn = "player";
    let waitingForAIShot = false;

    const POCKET_RADIUS = 26;
    const pockets = [
      { x: 5, y: 5 },
      { x: width / 2, y: 5 },
      { x: width - 5, y: 5 },
      { x: 5, y: height - 5 },
      { x: width / 2, y: height - 5 },
      { x: width - 5, y: height - 5 }
    ];

    function resetTable() {
      balls = [];
      sunkCount = 0;
      updateScore();

      cueBall = createBall(150, height / 2, 0, 0, "white", true);
      balls.push(cueBall);

      const startX = width - 200;
      const startY = height / 2;
      let rows = 5;
      let number = 1;

      for (let row = 0; row < rows; row++) {
        for (let i = 0; i <= row; i++) {
          const x = startX + row * (BALL_RADIUS * 2 + 3);
          const y = startY - row * BALL_RADIUS + i * BALL_RADIUS * 2;
          const color = ballColor(number);
          balls.push(createBall(x, y, 0, 0, color, false, number));
          number++;
          if (number > 15) break;
        }
        if (number > 15) break;
      }

      currentTurn = "player";
      waitingForAIShot = false;
      updateTurnDisplay();
    }

    function createBall(x, y, vx, vy, color, isCue = false, number = null) {
      return { x, y, vx, vy, color, isCue, number, sunk: false };
    }

    function ballColor(num) {
      const colors = {
        1: "#f6d000", 2: "#0033cc", 3: "#cc3300", 4: "#550080",
        5: "#ff6600", 6: "#006633", 7: "#660000", 8: "#000000",
        9: "#f6d000", 10: "#0033cc", 11: "#cc3300", 12: "#550080",
        13: "#ff6600", 14: "#006633", 15: "#660000"
      };
      return colors[num] || "#cccccc";
    }

    function updateScore() {
      scoreDisplay.textContent = `Sunk balls: ${sunkCount}`;
    }

    function updateTurnDisplay() {
      turnDisplay.textContent = vsAI
        ? (currentTurn === "player" ? "Turn: Player" : "Turn: AI")
        : "Turn: Player";
    }

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY
      };
    }

    canvas.addEventListener("mousedown", (e) => {
      if (vsAI && currentTurn !== "player") return;

      const { x: mx, y: my } = getMousePos(e);

      const dx = mx - cueBall.x;
      const dy = my - cueBall.y;
      const dist = Math.hypot(dx, dy);

      if (dist <= BALL_RADIUS + 5 && allBallsStopped()) {
        isAiming = true;
        mousePos = { x: mx, y: my };
      }
    });

    canvas.addEventListener("mousemove", (e) => {
      if (!isAiming) return;
      mousePos = getMousePos(e);
    });

    canvas.addEventListener("mouseup", () => {
      if (!isAiming) return;
      isAiming = false;

      const dx = mousePos.x - cueBall.x;
      const dy = mousePos.y - cueBall.y;

      const angle = Math.atan2(dy, dx);

      const pullBack = Math.hypot(dx, dy);
      const maxPull = 150;
      const power = Math.min(pullBack, maxPull) / 8;

      cueBall.vx = -Math.cos(angle) * power;
      cueBall.vy = -Math.sin(angle) * power;

      if (vsAI) {
        currentTurn = "ai";
        updateTurnDisplay();
        waitingForAIShot = true;
      }
    });

    function allBallsStopped() {
      return balls.every(b =>
        Math.abs(b.vx) < 0.01 &&
        Math.abs(b.vy) < 0.01
      );
    }

    function physicsStep() {
      balls.forEach(b => {
        if (b.sunk) return;
        b.x += b.vx;
        b.y += b.vy;
        b.vx *= FRICTION;
        b.vy *= FRICTION;

        if (Math.abs(b.vx) < 0.01) b.vx = 0;
        if (Math.abs(b.vy) < 0.01) b.vy = 0;

        if (b.x - BALL_RADIUS < 0) { b.x = BALL_RADIUS; b.vx *= -0.9; }
        if (b.x + BALL_RADIUS > width) { b.x = width - BALL_RADIUS; b.vx *= -0.9; }
        if (b.y - BALL_RADIUS < 0) { b.y = BALL_RADIUS; b.vy *= -0.9; }
        if (b.y + BALL_RADIUS > height) { b.y = height - BALL_RADIUS; b.vy *= -0.9; }
      });

      for (let i = 0; i < balls.length; i++) {
        for (let j = i + 1; j < balls.length; j++) {
          resolveCollision(balls[i], balls[j]);
        }
      }

      balls.forEach(b => {
        if (b.sunk) return;
        if (isInPocket(b)) {
          if (b.isCue) {
            b.x = 150;
            b.y = height / 2;
            b.vx = 0;
            b.vy = 0;
          } else {
            b.sunk = true;
            b.vx = 0;
            b.vy = 0;
            sunkCount++;
            updateScore();
          }
        }
      });

      if (vsAI && currentTurn === "ai" && waitingForAIShot && allBallsStopped()) {
        waitingForAIShot = false;
        setTimeout(aiTakeShot, 600);
      }
    }

    function isInPocket(ball) {
      return pockets.some(p =>
        Math.hypot(ball.x - p.x, ball.y - p.y) < POCKET_RADIUS + BALL_RADIUS
      );
    }

    function resolveCollision(b1, b2) {
      if (b1.sunk || b2.sunk) return;

      const dx = b2.x - b1.x;
      const dy = b2.y - b1.y;
      const dist = Math.hypot(dx, dy);

      if (dist === 0 || dist > BALL_RADIUS * 2) return;

      const overlap = BALL_RADIUS * 2 - dist;
      const nx = dx / dist;
      const ny = dy / dist;

      b1.x -= nx * overlap / 2;
      b1.y -= ny * overlap / 2;
      b2.x += nx * overlap / 2;
      b2.y += ny * overlap / 2;

      const p = b1.vx * nx + b1.vy * ny;
      const q = b2.vx * nx + b2.vy * ny;

      const newP = q;
      const newQ = p;

      b1.vx += (newP - p) * nx;
      b1.vy += (newP - p) * ny;

      b2.vx += (newQ - q) * nx;
      b2.vy += (newQ - q) * ny;
    }

    function drawTable() {
      ctx.fillStyle = "#116b3a";
      ctx.fillRect(0, 0, width, height);

      ctx.fillStyle = "#111";
      pockets.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, POCKET_RADIUS, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawBalls() {
      balls.forEach(b => {
        if (b.sunk) return;
        ctx.beginPath();
        ctx.arc(b.x, b.y, BALL_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = b.color;
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.stroke();

        if (!b.isCue && b.number != null) {
          ctx.fillStyle = "#fff";
          ctx.font = "10px system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(b.number, b.x, b.y);
        }
      });
    }

    function drawAimLine() {
      if (!isAiming || !allBallsStopped()) return;

      const dx = mousePos.x - cueBall.x;
      const dy = mousePos.y - cueBall.y;
      const pullBack = Math.hypot(dx, dy);

      ctx.strokeStyle = `rgba(255,255,255,${Math.min(1, pullBack / 120)})`;
      ctx.lineWidth = 2;
      ctx.setLineDash([10, 6]);

      ctx.beginPath();
      ctx.moveTo(cueBall.x, cueBall.y);
      ctx.lineTo(mousePos.x, mousePos.y);
      ctx.stroke();

      ctx.setLineDash([]);
    }

    function loop() {
      physicsStep();
      ctx.clearRect(0, 0, width, height);
      drawTable();
      drawBalls();
      drawAimLine();
      requestAnimationFrame(loop);
    }

    function aiTakeShot() {
      const targets = balls.filter(b => !b.sunk && !b.isCue);
      if (targets.length === 0) {
        currentTurn = "player";
        updateTurnDisplay();
        return;
      }

      const target = targets[Math.floor(Math.random() * targets.length)];
      const dx = target.x - cueBall.x;
      const dy = target.y - cueBall.y;
      const angle = Math.atan2(dy, dx);

      const power = 20 + Math.random() * 30;

      cueBall.vx = Math.cos(angle) * (power / 10);
      cueBall.vy = Math.sin(angle) * (power / 10);

      currentTurn = "player";
      updateTurnDisplay();
    }

    player1Btn.addEventListener("click", () => {
      vsAI = false;
      player1Btn.classList.add("active");
      vsAiBtn.classList.remove("active");
      resetTable();
    });

    vsAiBtn.addEventListener("click", () => {
      vsAI = true;
      player1Btn.classList.remove("active");
      vsAiBtn.classList.add("active");
      resetTable();
    });

    resetTable();
    loop();
  </script>
</body>
</html>
