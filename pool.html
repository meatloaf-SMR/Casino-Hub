<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pool</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #0b1924, #02070b 70%);
      color: #f4f4f4;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }

    h1 {
      margin-bottom: 10px;
    }

    #topBar {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }

    .modeBtn {
      padding: 6px 12px;
      border-radius: 999px;
      border: none;
      background: #f9d675;
      color: #111;
      cursor: pointer;
      font-size: 14px;
      box-shadow: 0 3px 0 #8a6220;
    }

    .modeBtn:active {
      transform: translateY(1px);
      box-shadow: 0 1px 0 #8a6220;
    }

    #scoreDisplay {
      margin-left: 10px;
      font-size: 14px;
      opacity: 0.9;
    }

    #poolCanvas {
      background: #116b3a; /* felt */
      border-radius: 16px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.6);
      border: 18px solid #5b3a1a; /* wood rails */
      display: block;
    }

    #bottomBar {
      margin-top: 12px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #powerLabel {
      font-size: 14px;
    }

    #powerBar {
      width: 200px;
    }

    #hint {
      font-size: 13px;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <h1>Pool</h1>

  <div id="topBar">
    <button class="modeBtn" id="player1Btn">1 Player</button>
    <button class="modeBtn" id="vsAiBtn" disabled>Vs AI (coming soon)</button>
    <span id="scoreDisplay">Sunk balls: 0</span>
  </div>

  <canvas id="poolCanvas" width="800" height="400"></canvas>

  <div id="bottomBar">
    <span id="powerLabel">Shot power:</span>
    <input type="range" id="powerBar" min="10" max="60" value="30">
    <span id="hint">Click and drag from cue ball to aim, release to shoot.</span>
  </div>

  <script>
    const canvas = document.getElementById("poolCanvas");
    const ctx = canvas.getContext("2d");

    const width = canvas.width;
    const height = canvas.height;

    const BALL_RADIUS = 10;
    const FRICTION = 0.99;
    const MIN_SPEED = 0.05;

    let balls = [];
    let cueBall;
    let isAiming = false;
    let mousePos = { x: 0, y: 0 };
    let sunkCount = 0;

    const scoreDisplay = document.getElementById("scoreDisplay");
    const powerBar = document.getElementById("powerBar");

    // Pockets: 6 circular zones
    const POCKET_RADIUS = 18;
    const pockets = [
      { x: 0, y: 0 },
      { x: width / 2, y: 0 },
      { x: width, y: 0 },
      { x: 0, y: height },
      { x: width / 2, y: height },
      { x: width, y: height }
    ];

    function resetTable() {
      balls = [];
      sunkCount = 0;
      updateScore();

      // Cue ball on left
      cueBall = createBall(150, height / 2, 0, 0, "white", true);
      balls.push(cueBall);

      // Rack of balls on the right
      const startX = width - 200;
      const startY = height / 2;
      let rows = 5;
      let number = 1;

      for (let row = 0; row < rows; row++) {
        for (let i = 0; i <= row; i++) {
          const x = startX + row * (BALL_RADIUS * 2 + 1);
          const y = startY - row * BALL_RADIUS + i * BALL_RADIUS * 2;
          const color = ballColor(number);
          balls.push(createBall(x, y, 0, 0, color, false, number));
          number++;
          if (number > 15) break;
        }
        if (number > 15) break;
      }
    }

    function createBall(x, y, vx, vy, color, isCue = false, number = null) {
      return { x, y, vx, vy, color, isCue, number, sunk: false };
    }

    function ballColor(num) {
      // Simple mapping of some typical pool colors
      const colors = {
        1: "#f6d000", // yellow
        2: "#0033cc", // blue
        3: "#cc3300", // red
        4: "#550080", // purple
        5: "#ff6600", // orange
        6: "#006633", // green
        7: "#660000", // maroon
        8: "#000000", // black
        9: "#f6d000",
        10: "#0033cc",
        11: "#cc3300",
        12: "#550080",
        13: "#ff6600",
        14: "#006633",
        15: "#660000"
      };
      return colors[num] || "#cccccc";
    }

    function updateScore() {
      scoreDisplay.textContent = `Sunk balls: ${sunkCount}`;
    }

    // Input handling
    canvas.addEventListener("mousedown", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      const dx = mx - cueBall.x;
      const dy = my - cueBall.y;
      const dist = Math.hypot(dx, dy);

      if (dist <= BALL_RADIUS + 5 && allBallsStopped()) {
        isAiming = true;
        mousePos = { x: mx, y: my };
      }
    });

    canvas.addEventListener("mousemove", (e) => {
      if (!isAiming) return;
      const rect = canvas.getBoundingClientRect();
      mousePos.x = e.clientX - rect.left;
      mousePos.y = e.clientY - rect.top;
    });

    canvas.addEventListener("mouseup", (e) => {
      if (!isAiming) return;
      isAiming = false;

      const dx = mousePos.x - cueBall.x;
      const dy = mousePos.y - cueBall.y;

      const angle = Math.atan2(dy, dx);
      const power = parseFloat(powerBar.value); // 10–60

      // Shoot opposite direction (pull back effect)
      cueBall.vx = -Math.cos(angle) * (power / 10);
      cueBall.vy = -Math.sin(angle) * (power / 10);
    });

    function allBallsStopped() {
      return balls.every(b => Math.hypot(b.vx, b.vy) < MIN_SPEED);
    }

    function physicsStep() {
      // Move
      balls.forEach(b => {
        if (b.sunk) return;
        b.x += b.vx;
        b.y += b.vy;
        b.vx *= FRICTION;
        b.vy *= FRICTION;

        if (Math.hypot(b.vx, b.vy) < MIN_SPEED) {
          b.vx = 0;
          b.vy = 0;
        }

        // Cushion collisions
        if (b.x - BALL_RADIUS < 0) {
          b.x = BALL_RADIUS;
          b.vx *= -1;
        }
        if (b.x + BALL_RADIUS > width) {
          b.x = width - BALL_RADIUS;
          b.vx *= -1;
        }
        if (b.y - BALL_RADIUS < 0) {
          b.y = BALL_RADIUS;
          b.vy *= -1;
        }
        if (b.y + BALL_RADIUS > height) {
          b.y = height - BALL_RADIUS;
          b.vy *= -1;
        }
      });

      // Ball-ball collisions
      for (let i = 0; i < balls.length; i++) {
        for (let j = i + 1; j < balls.length; j++) {
          resolveCollision(balls[i], balls[j]);
        }
      }

      // Pocket detection
      balls.forEach(b => {
        if (b.sunk) return;
        if (isInPocket(b)) {
          if (b.isCue) {
            // Scratch: reset cue ball
            b.x = 150;
            b.y = height / 2;
            b.vx = 0;
            b.vy = 0;
          } else {
            b.sunk = true;
            b.vx = 0;
            b.vy = 0;
            sunkCount++;
            updateScore();
          }
        }
      });
    }

    function isInPocket(ball) {
      for (const p of pockets) {
        const dx = ball.x - p.x;
        const dy = ball.y - p.y;
        const dist = Math.hypot(dx, dy);
        if (dist < POCKET_RADIUS) return true;
      }
      return false;
    }

    function resolveCollision(b1, b2) {
      if (b1.sunk || b2.sunk) return;

      const dx = b2.x - b1.x;
      const dy = b2.y - b1.y;
      const dist = Math.hypot(dx, dy);

      if (dist === 0 || dist > BALL_RADIUS * 2) return;

      // Overlap correction
      const overlap = BALL_RADIUS * 2 - dist;
      const nx = dx / dist;
      const ny = dy / dist;

      b1.x -= nx * overlap / 2;
      b1.y -= ny * overlap / 2;
      b2.x += nx * overlap / 2;
      b2.y += ny * overlap / 2;

      // Relative velocity
      const dvx = b2.vx - b1.vx;
      const dvy = b2.vy - b1.vy;
      const relVel = dvx * nx + dvy * ny;

      if (relVel > 0) return;

      const impulse = -relVel; // equal mass
      const ix = impulse * nx;
      const iy = impulse * ny;

      b1.vx -= ix / 2;
      b1.vy -= iy / 2;
      b2.vx += ix / 2;
      b2.vy += iy / 2;
    }

    function drawTable() {
      // Felt
      ctx.fillStyle = "#116b3a";
      ctx.fillRect(0, 0, width, height);

      // Pockets (dark circles)
      ctx.fillStyle = "#111";
      for (const p of pockets) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, POCKET_RADIUS, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawBalls() {
      balls.forEach(b => {
        if (b.sunk) return;
        ctx.beginPath();
        ctx.arc(b.x, b.y, BALL_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = b.color;
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1;
        ctx.stroke();

        // Number (optional, small)
        if (!b.isCue && b.number != null) {
          ctx.fillStyle = "#fff";
          ctx.font = "10px system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(b.number.toString(), b.x, b.y);
        }
      });
    }

    function drawAimLine() {
      if (!isAiming) return;
      if (!allBallsStopped()) return;

      ctx.strokeStyle = "rgba(255,255,255,0.7)";
      ctx.lineWidth = 2;
      ctx.setLineDash([10, 6]);
      ctx.beginPath();
      ctx.moveTo(cueBall.x, cueBall.y);
      ctx.lineTo(mousePos.x, mousePos.y);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function loop() {
      physicsStep();

      ctx.clearRect(0, 0, width, height);
      drawTable();
      drawBalls();
      drawAimLine();

      requestAnimationFrame(loop);
    }

    // Mode buttons (AI placeholder)
    document.getElementById("player1Btn").addEventListener("click", () => {
      // Right now just resets the table
      resetTable();
    });

    document.getElementById("vsAiBtn").addEventListener("click", () => {
      // Placeholder: we’ll wire AI logic later
      alert("AI mode coming soon! For now, use 1 Player.");
    });

    // Init
    resetTable();
    loop();
  </script>
</body>
</html>
