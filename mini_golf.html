<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini Golf – Infinite</title>
<style>
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    font-family: system-ui, sans-serif;
  }

  body {
    background: radial-gradient(circle at top, #0b1924, #02070b 70%);
    color: #f4f4f4;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
  }

  h1 {
    font-size: 36px;
    letter-spacing: 3px;
    margin-bottom: 10px;
  }

  #infoBar {
    margin-bottom: 15px;
    font-size: 18px;
  }

  #infoBar span {
    margin-right: 20px;
  }

  #gameContainer {
    background: #145b27;
    border-radius: 16px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.7);
    padding: 15px;
  }

  canvas {
    display: block;
    background: #1b7a35;
    border-radius: 12px;
  }

  #controls {
    margin-top: 10px;
    display: flex;
    gap: 10px;
    justify-content: center;
  }

  button {
    padding: 8px 18px;
    font-size: 16px;
    border-radius: 999px;
    border: none;
    cursor: pointer;
    background: radial-gradient(circle at top, #f9d675, #d8a73e);
    color: #111;
    box-shadow: 0 3px 0 #8a6220;
    transition: 0.1s;
  }

  button:hover {
    filter: brightness(1.05);
  }

  button:active {
    transform: translateY(2px);
    box-shadow: 0 1px 0 #8a6220;
  }
</style>
</head>
<body>

<h1>Mini Golf</h1>
<div id="infoBar">
  <span id="holeDisplay">Hole: 1</span>
  <span id="strokesDisplay">Strokes: 0</span>
</div>

<div id="gameContainer">
  <canvas id="gameCanvas" width="800" height="500"></canvas>
  <div id="controls">
    <button onclick="resetBall()">Reset Ball</button>
    <button onclick="newHole()">New Hole</button>
  </div>
</div>

<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  const holeDisplay = document.getElementById("holeDisplay");
  const strokesDisplay = document.getElementById("strokesDisplay");

  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;

  // Ball properties
  let ball = {
    x: WIDTH / 4,
    y: HEIGHT / 2,
    radius: 10,
    vx: 0,
    vy: 0
  };

  // Hole properties
  let hole = {
    x: (3 * WIDTH) / 4,
    y: HEIGHT / 2,
    radius: 14
  };

  // Obstacles: array of {x, y, w, h}
  let obstacles = [];

  let isDragging = false;
  let dragStart = { x: 0, y: 0 };
  let strokeCount = 0;
  let holeNumber = 1;

  const FRICTION = 0.985;        // slows ball
  const MIN_SPEED = 0.02;        // threshold to stop
  const MAX_SHOT_POWER = 140;    // max arrow length
  const BALL_SPEED_FACTOR = 0.08; // converts drag distance to velocity

  function resetBall() {
    // Place ball somewhere near left side, not colliding
    placeBall();
    ball.vx = 0;
    ball.vy = 0;
    strokeCount = 0;
    updateUI();
  }

  function newHole() {
    holeNumber++;
    generateCourse();
    strokeCount = 0;
    updateUI();
  }

  function updateUI() {
    holeDisplay.textContent = "Hole: " + holeNumber;
    strokesDisplay.textContent = "Strokes: " + strokeCount;
  }

  function generateCourse() {
    obstacles = [];

    // Random hole placement
    placeHole();

    // Random obstacles
    const obstacleCount = 5 + Math.floor(Math.random() * 6); // 5–10 obstacles
    let attempts = 0;

    while (obstacles.length < obstacleCount && attempts < 200) {
      attempts++;
      const w = 80 + Math.random() * 120;
      const h = 20 + Math.random() * 60;
      const x = 40 + Math.random() * (WIDTH - 80 - w);
      const y = 40 + Math.random() * (HEIGHT - 80 - h);

      const newObs = { x, y, w, h };

      // Avoid overlapping hole too closely
      if (rectCircleOverlap(newObs, hole.x, hole.y, hole.radius + 15)) continue;

      // Avoid overlapping other obstacles
      let overlap = obstacles.some(o => rectOverlap(o, newObs));
      if (overlap) continue;

      obstacles.push(newObs);
    }

    // Place ball after obstacles so we can avoid them
    placeBall();
  }

  function placeHole() {
    // Hole somewhere in right half
    hole.x = WIDTH * (0.55 + Math.random() * 0.35);
    hole.y = HEIGHT * (0.15 + Math.random() * 0.7);
  }

  function placeBall() {
    // Try random positions on left half until we find a free spot
    let placed = false;
    let attempts = 0;

    while (!placed && attempts < 200) {
      attempts++;
      const x = WIDTH * (0.1 + Math.random() * 0.25);
      const y = HEIGHT * (0.15 + Math.random() * 0.7);

      if (pointInObstacle(x, y)) continue;
      if (distance(x, y, hole.x, hole.y) < 120) continue;

      ball.x = x;
      ball.y = y;
      placed = true;
    }

    if (!placed) {
      // Fallback
      ball.x = WIDTH / 4;
      ball.y = HEIGHT / 2;
    }
  }

  function distance(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
  }

  function rectOverlap(a, b) {
    return !(
      a.x + a.w < b.x ||
      b.x + b.w < a.x ||
      a.y + a.h < b.y ||
      b.y + b.h < a.y
    );
  }

  function rectCircleOverlap(rect, cx, cy, radius) {
    const closestX = clamp(cx, rect.x, rect.x + rect.w);
    const closestY = clamp(cy, rect.y, rect.y + rect.h);
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx * dx + dy * dy) < (radius * radius);
  }

  function pointInObstacle(px, py) {
    return obstacles.some(o =>
      px > o.x && px < o.x + o.w && py > o.y && py < o.y + o.h
    );
  }

  function clamp(v, min, max) {
    return v < min ? min : v > max ? max : v;
  }

  // Mouse input
  canvas.addEventListener("mousedown", e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    // Only allow dragging when ball is basically stopped
    if (ball.vx * ball.vx + ball.vy * ball.vy < 0.01 &&
        distance(mx, my, ball.x, ball.y) <= ball.radius + 15) {
      isDragging = true;
      dragStart.x = mx;
      dragStart.y = my;
    }
  });

  canvas.addEventListener("mousemove", e => {
    if (!isDragging) return;
    // Just redraw; the arrow is drawn in render()
  });

  canvas.addEventListener("mouseup", e => {
    if (!isDragging) return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    isDragging = false;

    const dx = dragStart.x - mx;
    const dy = dragStart.y - my;
    const power = Math.min(Math.sqrt(dx * dx + dy * dy), MAX_SHOT_POWER);

    if (power > 5) {
      const angle = Math.atan2(dy, dx);
      const sx = Math.cos(angle) * power * BALL_SPEED_FACTOR;
      const sy = Math.sin(angle) * power * BALL_SPEED_FACTOR;
      ball.vx = sx;
      ball.vy = sy;
      strokeCount++;
      updateUI();
    }
  });

  function update() {
    // Move ball
    ball.x += ball.vx;
    ball.y += ball.vy;

    // Friction
    ball.vx *= FRICTION;
    ball.vy *= FRICTION;

    if (Math.abs(ball.vx) < MIN_SPEED) ball.vx = 0;
    if (Math.abs(ball.vy) < MIN_SPEED) ball.vy = 0;

    // Wall collisions (edges of canvas)
    if (ball.x - ball.radius < 0) {
      ball.x = ball.radius;
      ball.vx = -ball.vx;
    } else if (ball.x + ball.radius > WIDTH) {
      ball.x = WIDTH - ball.radius;
      ball.vx = -ball.vx;
    }

    if (ball.y - ball.radius < 0) {
      ball.y = ball.radius;
      ball.vy = -ball.vy;
    } else if (ball.y + ball.radius > HEIGHT) {
      ball.y = HEIGHT - ball.radius;
      ball.vy = -ball.vy;
    }

    // Obstacle collisions (simple reflection)
    for (const o of obstacles) {
      if (ball.x + ball.radius > o.x &&
          ball.x - ball.radius < o.x + o.w &&
          ball.y + ball.radius > o.y &&
          ball.y - ball.radius < o.y + o.h) {

        // Determine side of collision
        const overlapLeft   = (ball.x + ball.radius) - o.x;
        const overlapRight  = (o.x + o.w) - (ball.x - ball.radius);
        const overlapTop    = (ball.y + ball.radius) - o.y;
        const overlapBottom = (o.y + o.h) - (ball.y - ball.radius);

        const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

        if (minOverlap === overlapLeft) {
          ball.x = o.x - ball.radius;
          ball.vx = -Math.abs(ball.vx);
        } else if (minOverlap === overlapRight) {
          ball.x = o.x + o.w + ball.radius;
          ball.vx = Math.abs(ball.vx);
        } else if (minOverlap === overlapTop) {
          ball.y = o.y - ball.radius;
          ball.vy = -Math.abs(ball.vy);
        } else {
          ball.y = o.y + o.h + ball.radius;
          ball.vy = Math.abs(ball.vy);
        }
      }
    }

    // Check hole
    if (distance(ball.x, ball.y, hole.x, hole.y) < hole.radius - 2 &&
        ball.vx === 0 && ball.vy === 0) {
      // Slight animation idea: you could add effects here
      newHole();
    }
  }

  function draw() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Background
    ctx.fillStyle = "#1b7a35";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Obstacles
    ctx.fillStyle = "#0f3b1c";
    ctx.strokeStyle = "rgba(0,0,0,0.4)";
    ctx.lineWidth = 2;
    for (const o of obstacles) {
      ctx.fillRect(o.x, o.y, o.w, o.h);
      ctx.strokeRect(o.x, o.y, o.w, o.h);
    }

    // Hole
    ctx.beginPath();
    ctx.arc(hole.x, hole.y, hole.radius, 0, Math.PI * 2);
    ctx.fillStyle = "#000000";
    ctx.fill();
    ctx.closePath();

    // Hole rim
    ctx.beginPath();
    ctx.arc(hole.x, hole.y, hole.radius + 3, 0, Math.PI * 2);
    ctx.strokeStyle = "#f9d675";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.closePath();

    // Ball shadow
    ctx.beginPath();
    ctx.ellipse(ball.x + 3, ball.y + 4, ball.radius * 0.9, ball.radius * 0.6, 0, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(0,0,0,0.3)";
    ctx.fill();
    ctx.closePath();

    // Ball
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fillStyle = "#ffffff";
    ctx.fill();
    ctx.strokeStyle = "#d0d0d0";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.closePath();

    // Aim arrow (while dragging)
    if (isDragging) {
      const rect = canvas.getBoundingClientRect();
      // Use last mouse position from event? Simpler: use current cursor via pointer capture
      // For now, we just visualize from ball to dragStart
      const sx = ball.x;
      const sy = ball.y;
      const ex = dragStart.x;
      const ey = dragStart.y;
      let dx = sx - ex;
      let dy = sy - ey;
      let dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > MAX_SHOT_POWER) {
        dx = (dx / dist) * MAX_SHOT_POWER;
        dy = (dy / dist) * MAX_SHOT_POWER;
      }

      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx + dx * -0.6, sy + dy * -0.6);
      ctx.strokeStyle = "#f9d675";
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.closePath();
    }
  }

  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }

  // Initialize
  generateCourse();
  updateUI();
  loop();
</script>

</body>
</html>
