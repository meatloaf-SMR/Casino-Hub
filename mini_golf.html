<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mini Golf</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #0b1924, #02070b 70%);
      color: #f4f4f4;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }

    h1 {
      margin-bottom: 6px;
    }

    #topBar {
      display: flex;
      gap: 14px;
      align-items: center;
      margin-bottom: 10px;
      flex-wrap: wrap;
      justify-content: center;
      font-size: 14px;
    }

    #info {
      font-size: 13px;
      opacity: 0.9;
      margin-bottom: 8px;
    }

    #golfCanvas {
      background: #0f5b30;
      border-radius: 16px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.6);
      border: 18px solid #5b3a1a;
      display: block;
    }
  </style>
</head>
<body>
  <h1>Mini Golf</h1>

  <div id="topBar">
    <span id="holeDisplay">Hole: 1</span>
    <span id="strokeDisplay">Strokes this hole: 0</span>
    <span id="totalStrokeDisplay">Total strokes: 0</span>
  </div>

  <div id="info">Click and drag from the ball to aim and shoot. Sink it to generate a new random hole.</div>

  <canvas id="golfCanvas" width="800" height="450"></canvas>

  <script>
    const canvas = document.getElementById("golfCanvas");
    const ctx = canvas.getContext("2d");
    const W = canvas.width;
    const H = canvas.height;

    const holeDisplay = document.getElementById("holeDisplay");
    const strokeDisplay = document.getElementById("strokeDisplay");
    const totalStrokeDisplay = document.getElementById("totalStrokeDisplay");

    const BALL_RADIUS = 8;
    const HOLE_RADIUS = 10;
    const FRICTION = 0.985;      // stronger friction for stability
    const STOP_THRESHOLD = 0.05; // stop sooner

    let ball = { x: 0, y: 0, vx: 0, vy: 0 };
    let hole = { x: 0, y: 0 };
    // obstacles are simple rectangles: { x, y, w, h }
    let obstacles = [];

    let isAiming = false;
    let mousePos = { x: 0, y: 0 };

    let strokesThisHole = 0;
    let totalStrokes = 0;
    let holeNumber = 1;

    function rand(min, max) {
      return Math.random() * (max - min) + min;
    }

    function updateHUD() {
      holeDisplay.textContent = "Hole: " + holeNumber;
      strokeDisplay.textContent = "Strokes this hole: " + strokesThisHole;
      totalStrokeDisplay.textContent = "Total strokes: " + totalStrokes;
    }

    function generateHole() {
      obstacles = [];
      strokesThisHole = 0;
      updateHUD();

      ball.x = rand(80, 140);
      ball.y = rand(80, H - 80);
      ball.vx = 0;
      ball.vy = 0;

      hole.x = rand(W - 180, W - 80);
      hole.y = rand(80, H - 80);

      const count = 3 + Math.floor(Math.random() * 3);

      for (let i = 0; i < count; i++) {
        const w = rand(60, 160);
        const h = rand(30, 80);
        const x = rand(180, W - 220);
        const y = rand(70, H - 70 - h);

        obstacles.push({ x, y, w, h });
      }
    }

    function allStopped() {
      return Math.hypot(ball.vx, ball.vy) < STOP_THRESHOLD;
    }

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY
      };
    }

    canvas.addEventListener("mousedown", (e) => {
      if (!allStopped()) return;

      const m = getMousePos(e);
      const dx = m.x - ball.x;
      const dy = m.y - ball.y;
      const dist = Math.hypot(dx, dy);

      if (dist <= BALL_RADIUS + 14) {
        isAiming = true;
        mousePos = m;
      }
    });

    canvas.addEventListener("mousemove", (e) => {
      if (!isAiming) return;
      mousePos = getMousePos(e);
    });

    canvas.addEventListener("mouseup", () => {
      if (!isAiming) return;
      isAiming = false;

      const dx = mousePos.x - ball.x;
      const dy = mousePos.y - ball.y;
      const distance = Math.hypot(dx, dy);
      if (distance === 0) return;

      const angle = Math.atan2(dy, dx);
      const maxPull = 160;
      const power = Math.min(distance, maxPull) / 8; // slightly stronger

      ball.vx = -Math.cos(angle) * power;
      ball.vy = -Math.sin(angle) * power;

      strokesThisHole++;
      totalStrokes++;
      updateHUD();
    });

    function resolveRectCollision(rect) {
      const nearestX = Math.max(rect.x, Math.min(ball.x, rect.x + rect.w));
      const nearestY = Math.max(rect.y, Math.min(ball.y, rect.y + rect.h));

      const dx = ball.x - nearestX;
      const dy = ball.y - nearestY;
      const dist = Math.hypot(dx, dy);

      if (dist < BALL_RADIUS && dist > 0) {
        const overlap = BALL_RADIUS - dist;

        const absDX = Math.abs(dx);
        const absDY = Math.abs(dy);

        if (absDX > absDY) {
          if (dx > 0) {
            ball.x += overlap;
          } else {
            ball.x -= overlap;
          }
          ball.vx = -ball.vx * 0.8;
        } else {
          if (dy > 0) {
            ball.y += overlap;
          } else {
            ball.y -= overlap;
          }
          ball.vy = -ball.vy * 0.8;
        }
      }
    }

    function physicsStep() {
      if (allStopped()) {
        ball.vx = 0;
        ball.vy = 0;
        return;
      }

      ball.x += ball.vx;
      ball.y += ball.vy;

      ball.vx *= FRICTION;
      ball.vy *= FRICTION;

      if (Math.abs(ball.vx) < STOP_THRESHOLD) ball.vx = 0;
      if (Math.abs(ball.vy) < STOP_THRESHOLD) ball.vy = 0;

      if (ball.x - BALL_RADIUS < 30) {
        ball.x = 30 + BALL_RADIUS;
        ball.vx = -ball.vx * 0.8;
      }
      if (ball.x + BALL_RADIUS > W - 30) {
        ball.x = W - 30 - BALL_RADIUS;
        ball.vx = -ball.vx * 0.8;
      }
      if (ball.y - BALL_RADIUS < 30) {
        ball.y = 30 + BALL_RADIUS;
        ball.vy = -ball.vy * 0.8;
      }
      if (ball.y + BALL_RADIUS > H - 30) {
        ball.y = H - 30 - BALL_RADIUS;
        ball.vy = -ball.vy * 0.8;
      }

      for (const rect of obstacles) {
        resolveRectCollision(rect);
      }

      const dxh = ball.x - hole.x;
      const dyh = ball.y - hole.y;
      const distHole = Math.hypot(dxh, dyh);
      if (distHole < HOLE_RADIUS - 2 && Math.hypot(ball.vx, ball.vy) < 1.0) {
        ball.x = hole.x;
        ball.y = hole.y;
        ball.vx = 0;
        ball.vy = 0;

        setTimeout(() => {
          holeNumber++;
          generateHole();
        }, 600);
      }
    }

    function drawCourse() {
      ctx.fillStyle = "#0f5b30";
      ctx.fillRect(0, 0, W, H);

      ctx.strokeStyle = "#09381d";
      ctx.lineWidth = 18;
      ctx.strokeRect(25, 25, W - 50, H - 50);

      ctx.strokeStyle = "#072514";
      ctx.lineWidth = 2;
      ctx.strokeRect(25, 25, W - 50, H - 50);

      ctx.strokeStyle = "#083c20";
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(50, ball.y);
      ctx.lineTo(ball.x, ball.y);
      ctx.stroke();
    }

    function drawObstacles() {
      ctx.fillStyle = "#0b3019";
      obstacles.forEach(o => {
        ctx.fillRect(o.x, o.y, o.w, o.h);
      });
    }

    function drawHole() {
      ctx.beginPath();
      ctx.arc(hole.x, hole.y, HOLE_RADIUS, 0, Math.PI * 2);
      ctx.fillStyle = "#000000";
      ctx.fill();

      ctx.beginPath();
      ctx.arc(hole.x, hole.y, HOLE_RADIUS - 3, 0, Math.PI * 2);
      ctx.fillStyle = "#111111";
      ctx.fill();
    }

    function drawBall() {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI * 2);
      ctx.fillStyle = "#f5f5f5";
      ctx.fill();
      ctx.strokeStyle = "#bbbbbb";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function drawAimLine() {
      if (!isAiming || !allStopped()) return;

      const dx = mousePos.x - ball.x;
      const dy = mousePos.y - ball.y;
      const dist = Math.hypot(dx, dy);
      if (dist === 0) return;

      const maxPull = 160;
      const clamped = Math.min(dist, maxPull);

      const angle = Math.atan2(dy, dx);
      const ex = ball.x - Math.cos(angle) * clamped;
      const ey = ball.y - Math.sin(angle) * clamped;

      ctx.strokeStyle = "rgba(255,255,255,0.8)";
      ctx.lineWidth = 2;
      ctx.setLineDash([10, 6]);

      ctx.beginPath();
      ctx.moveTo(ball.x, ball.y);
      ctx.lineTo(ex, ey);
      ctx.stroke();

      ctx.setLineDash([]);
    }

    function loop() {
      physicsStep();

      ctx.clearRect(0, 0, W, H);
      drawCourse();
      drawObstacles();
      drawHole();
      drawBall();
      drawAimLine();

      requestAnimationFrame(loop);
    }

    generateHole();
    loop();
  </script>
</body>
</html>
