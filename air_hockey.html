<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Air Hockey</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #0b1924, #02070b 70%);
      color: #f4f4f4;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }

    h1 {
      margin-bottom: 6px;
    }

    #topBar {
      display: flex;
      gap: 14px;
      align-items: center;
      margin-bottom: 10px;
      flex-wrap: wrap;
      justify-content: center;
      font-size: 14px;
    }

    #status {
      font-size: 13px;
      opacity: 0.9;
      margin-bottom: 8px;
    }

    #hockeyCanvas {
      background: #084057;
      border-radius: 18px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.6);
      border: 18px solid #1d1d1d;
      display: block;
    }
  </style>
</head>
<body>
  <h1>Air Hockey</h1>

  <div id="topBar">
    <span id="playerScore">Player: 0</span>
    <span id="aiScore">AI: 0</span>
    <span id="goalTarget">First to 7</span>
  </div>

  <div id="status">Move your mouse to control the left paddle. Defend your goal and score on the AI.</div>

  <canvas id="hockeyCanvas" width="800" height="400"></canvas>

  <script>
    const canvas = document.getElementById("hockeyCanvas");
    const ctx = canvas.getContext("2d");
    const W = canvas.width;
    const H = canvas.height;

    const playerScoreEl = document.getElementById("playerScore");
    const aiScoreEl = document.getElementById("aiScore");
    const statusEl = document.getElementById("status");

    // Constants (simplified, arcade-style)
    const PUCK_RADIUS = 12;
    const PADDLE_RADIUS = 26;
    const FRICTION = 0.99;          // stronger friction = less runaway sliding
    const MAX_PUCK_SPEED = 14;
    const GOAL_WIDTH = 120;
    const WIN_SCORE = 7;

    const WALL_MARGIN = 10;

    let player = {
      x: W * 0.25,
      y: H / 2,
      radius: PADDLE_RADIUS,
      vx: 0,
      vy: 0
    };

    let ai = {
      x: W * 0.75,
      y: H / 2,
      radius: PADDLE_RADIUS,
      vx: 0,
      vy: 0
    };

    let puck = {
      x: W / 2,
      y: H / 2,
      vx: 0,
      vy: 0
    };

    let playerScore = 0;
    let aiScore = 0;

    let mousePos = { x: player.x, y: player.y };

    function clamp(val, min, max) {
      return Math.max(min, Math.min(max, val));
    }

    function resetRound(scoredBy) {
      puck.x = W / 2;
      puck.y = H / 2;
      puck.vx = (Math.random() < 0.5 ? 1 : -1) * 5;
      puck.vy = (Math.random() - 0.5) * 4;

      player.x = W * 0.25;
      player.y = H / 2;
      player.vx = 0;
      player.vy = 0;

      ai.x = W * 0.75;
      ai.y = H / 2;
      ai.vx = 0;
      ai.vy = 0;

      if (scoredBy === "player") {
        statusEl.textContent = "You scored! New round.";
      } else if (scoredBy === "ai") {
        statusEl.textContent = "AI scored. New round.";
      } else {
        statusEl.textContent = "Ready!";
      }
    }

    function resetGame() {
      playerScore = 0;
      aiScore = 0;
      updateScoreDisplay();
      statusEl.textContent = "New game! First to 7.";
      resetRound(null);
    }

    function updateScoreDisplay() {
      playerScoreEl.textContent = "Player: " + playerScore;
      aiScoreEl.textContent = "AI: " + aiScore;
    }

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY
      };
    }

    canvas.addEventListener("mousemove", (e) => {
      const m = getMousePos(e);
      mousePos.x = m.x;
      mousePos.y = m.y;
    });

    function updatePlayer() {
      // Target is mouse, but constrained to left half
      const targetX = clamp(mousePos.x, WALL_MARGIN + PADDLE_RADIUS, W / 2 - PADDLE_RADIUS - 10);
      const targetY = clamp(mousePos.y, WALL_MARGIN + PADDLE_RADIUS, H - WALL_MARGIN - PADDLE_RADIUS);

      const dx = targetX - player.x;
      const dy = targetY - player.y;
      const maxStep = 14; // limit speed to avoid insane paddle hits

      const dist = Math.hypot(dx, dy);
      if (dist > maxStep) {
        const ratio = maxStep / dist;
        player.vx = dx * ratio;
        player.vy = dy * ratio;
        player.x += player.vx;
        player.y += player.vy;
      } else {
        player.vx = dx;
        player.vy = dy;
        player.x = targetX;
        player.y = targetY;
      }
    }

    function updateAI() {
      // Simple arcade AI: moves toward puck when on its side
      const aiMaxSpeed = 8;

      let targetX = W * 0.75;
      let targetY = H / 2;

      if (puck.x > W / 2) {
        targetX = clamp(puck.x + 40, W / 2 + PADDLE_RADIUS + 5, W - WALL_MARGIN - PADDLE_RADIUS);
        targetY = clamp(puck.y, WALL_MARGIN + PADDLE_RADIUS, H - WALL_MARGIN - PADDLE_RADIUS);
      }

      const dx = targetX - ai.x;
      const dy = targetY - ai.y;
      const dist = Math.hypot(dx, dy);

      if (dist > 0) {
        const step = Math.min(aiMaxSpeed, dist);
        ai.vx = (dx / dist) * step;
        ai.vy = (dy / dist) * step;
        ai.x += ai.vx;
        ai.y += ai.vy;
      } else {
        ai.vx = 0;
        ai.vy = 0;
      }

      ai.x = clamp(ai.x, W / 2 + PADDLE_RADIUS + 5, W - WALL_MARGIN - PADDLE_RADIUS);
      ai.y = clamp(ai.y, WALL_MARGIN + PADDLE_RADIUS, H - WALL_MARGIN - PADDLE_RADIUS);
    }

    function handlePaddleCollision(paddle) {
      const dx = puck.x - paddle.x;
      const dy = puck.y - paddle.y;
      const dist = Math.hypot(dx, dy);
      const minDist = PUCK_RADIUS + paddle.radius;

      if (dist < minDist && dist > 0) {
        // Push puck out just enough to avoid overlap
        const overlap = minDist - dist;
        const nx = dx / dist;
        const ny = dy / dist;

        puck.x += nx * overlap;
        puck.y += ny * overlap;

        // Simple arcade impulse: puck goes away from paddle + some of paddle velocity
        const hitStrength = 0.5;
        puck.vx = nx * 8 + paddle.vx * hitStrength;
        puck.vy = ny * 8 + paddle.vy * hitStrength;

        // Clamp speed
        const speed = Math.hypot(puck.vx, puck.vy);
        if (speed > MAX_PUCK_SPEED) {
          const k = MAX_PUCK_SPEED / speed;
          puck.vx *= k;
          puck.vy *= k;
        }
      }
    }

    function updatePuck() {
      // Move
      puck.x += puck.vx;
      puck.y += puck.vy;

      // Friction
      puck.vx *= FRICTION;
      puck.vy *= FRICTION;

      // Stop tiny drift
      if (Math.abs(puck.vx) < 0.05) puck.vx = 0;
      if (Math.abs(puck.vy) < 0.05) puck.vy = 0;

      // Clamp speed
      const speed = Math.hypot(puck.vx, puck.vy);
      if (speed > MAX_PUCK_SPEED) {
        const k = MAX_PUCK_SPEED / speed;
        puck.vx *= k;
        puck.vy *= k;
      }

      // Top/bottom walls
      if (puck.y - PUCK_RADIUS < WALL_MARGIN) {
        puck.y = WALL_MARGIN + PUCK_RADIUS;
        puck.vy = -puck.vy;
      }
      if (puck.y + PUCK_RADIUS > H - WALL_MARGIN) {
        puck.y = H - WALL_MARGIN - PUCK_RADIUS;
        puck.vy = -puck.vy;
      }

      // Goals & side walls
      const leftGoalX = WALL_MARGIN;
      const rightGoalX = W - WALL_MARGIN;

      // Left side
      if (puck.x - PUCK_RADIUS < leftGoalX) {
        if (puck.y > H / 2 - GOAL_WIDTH / 2 && puck.y < H / 2 + GOAL_WIDTH / 2) {
          // AI scores
          aiScore++;
          updateScoreDisplay();
          if (aiScore >= WIN_SCORE) {
            statusEl.textContent = "AI wins! Resetting game...";
            setTimeout(resetGame, 1200);
          } else {
            resetRound("ai");
          }
          return;
        } else {
          puck.x = leftGoalX + PUCK_RADIUS;
          puck.vx = -puck.vx;
        }
      }

      // Right side
      if (puck.x + PUCK_RADIUS > rightGoalX) {
        if (puck.y > H / 2 - GOAL_WIDTH / 2 && puck.y < H / 2 + GOAL_WIDTH / 2) {
          // Player scores
          playerScore++;
          updateScoreDisplay();
          if (playerScore >= WIN_SCORE) {
            statusEl.textContent = "You win! Resetting game...";
            setTimeout(resetGame, 1200);
          } else {
            resetRound("player");
          }
          return;
        } else {
          puck.x = rightGoalX - PUCK_RADIUS;
          puck.vx = -puck.vx;
        }
      }

      // Paddle collisions (after movement, once per frame)
      handlePaddleCollision(player);
      handlePaddleCollision(ai);
    }

    function drawTable() {
      ctx.fillStyle = "#084057";
      ctx.fillRect(0, 0, W, H);

      // Outer border
      ctx.strokeStyle = "#0da4d6";
      ctx.lineWidth = 4;
      ctx.strokeRect(WALL_MARGIN, WALL_MARGIN, W - 2 * WALL_MARGIN, H - 2 * WALL_MARGIN);

      // Center line
      ctx.beginPath();
      ctx.moveTo(W / 2, WALL_MARGIN);
      ctx.lineTo(W / 2, H - WALL_MARGIN);
      ctx.strokeStyle = "rgba(255,255,255,0.3)";
      ctx.lineWidth = 2;
      ctx.setLineDash([10, 8]);
      ctx.stroke();
      ctx.setLineDash([]);

      // Center circle
      ctx.beginPath();
      ctx.arc(W / 2, H / 2, 50, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Goals
      ctx.fillStyle = "#111";
      ctx.fillRect(WALL_MARGIN - 2, H / 2 - GOAL_WIDTH / 2, 8, GOAL_WIDTH);
      ctx.fillRect(W - WALL_MARGIN - 6, H / 2 - GOAL_WIDTH / 2, 8, GOAL_WIDTH);
    }

    function drawPaddle(p, color) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius * 0.45, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(255,255,255,0.4)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function drawPuck() {
      ctx.beginPath();
      ctx.arc(puck.x, puck.y, PUCK_RADIUS, 0, Math.PI * 2);
      ctx.fillStyle = "#f5f5f5";
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(puck.x, puck.y, PUCK_RADIUS * 0.4, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(0,0,0,0.4)";
      ctx.lineWidth = 1.5;
      ctx.stroke();
    }

    function loop() {
      updatePlayer();
      updateAI();
      updatePuck();

      ctx.clearRect(0, 0, W, H);
      drawTable();
      drawPuck();
      drawPaddle(player, "#ffd34f");
      drawPaddle(ai, "#ff4f6a");

      requestAnimationFrame(loop);
    }

    resetGame();
    loop();
  </script>
</body>
</html>
