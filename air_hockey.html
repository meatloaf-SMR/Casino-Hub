<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Air Hockey</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #0b1924, #02070b 70%);
      color: #f4f4f4;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }

    h1 {
      margin-bottom: 6px;
    }

    #topBar {
      display: flex;
      gap: 14px;
      align-items: center;
      margin-bottom: 10px;
      flex-wrap: wrap;
      justify-content: center;
      font-size: 14px;
    }

    #status {
      font-size: 13px;
      opacity: 0.9;
      margin-bottom: 8px;
    }

    #hockeyCanvas {
      background: #084057;
      border-radius: 18px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.6);
      border: 18px solid #1d1d1d;
      display: block;
    }
  </style>
</head>
<body>
  <h1>Air Hockey</h1>

  <div id="topBar">
    <span id="playerScore">Player: 0</span>
    <span id="aiScore">AI: 0</span>
    <span id="goalTarget">First to 7</span>
  </div>

  <div id="status">Move your mouse to control the left paddle. Defend your goal and score on the AI.</div>

  <canvas id="hockeyCanvas" width="800" height="400"></canvas>

  <script>
    const canvas = document.getElementById("hockeyCanvas");
    const ctx = canvas.getContext("2d");
    const W = canvas.width;
    const H = canvas.height;

    const playerScoreEl = document.getElementById("playerScore");
    const aiScoreEl = document.getElementById("aiScore");
    const statusEl = document.getElementById("status");

    // Table / physics constants
    const PUCK_RADIUS = 12;
    const PADDLE_RADIUS = 26;
    const FRICTION = 0.995;    // very low, for that air hockey glide
    const BOUNCE_DAMPING = 0.99;
    const MAX_PUCK_SPEED = 18;
    const GOAL_WIDTH = 120;
    const WIN_SCORE = 7;

    // Player & AI
    let player = {
      x: W * 0.25,
      y: H / 2,
      radius: PADDLE_RADIUS,
      vx: 0,
      vy: 0,
      lastX: null,
      lastY: null
    };

    let ai = {
      x: W * 0.75,
      y: H / 2,
      radius: PADDLE_RADIUS,
      vx: 0,
      vy: 0
    };

    let puck = {
      x: W / 2,
      y: H / 2,
      vx: 0,
      vy: 0
    };

    let playerScore = 0;
    let aiScore = 0;

    let mousePos = { x: player.x, y: player.y };

    function resetRound(scoredBy) {
      puck.x = W / 2;
      puck.y = H / 2;
      puck.vx = (Math.random() < 0.5 ? 1 : -1) * 6;
      puck.vy = (Math.random() - 0.5) * 6;

      player.x = W * 0.25;
      player.y = H / 2;
      player.vx = 0;
      player.vy = 0;

      ai.x = W * 0.75;
      ai.y = H / 2;
      ai.vx = 0;
      ai.vy = 0;

      if (scoredBy === "player") {
        statusEl.textContent = "You scored! New round.";
      } else if (scoredBy === "ai") {
        statusEl.textContent = "AI scored. New round.";
      } else {
        statusEl.textContent = "Ready!";
      }
    }

    function resetGame() {
      playerScore = 0;
      aiScore = 0;
      updateScoreDisplay();
      statusEl.textContent = "New game! First to 7.";
      resetRound(null);
    }

    function updateScoreDisplay() {
      playerScoreEl.textContent = "Player: " + playerScore;
      aiScoreEl.textContent = "AI: " + aiScore;
    }

    function clamp(val, min, max) {
      return Math.max(min, Math.min(max, val));
    }

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY
      };
    }

    canvas.addEventListener("mousemove", (e) => {
      const m = getMousePos(e);
      mousePos.x = m.x;
      mousePos.y = m.y;
    });

    function updatePlayerPaddle() {
      const targetX = clamp(mousePos.x, PADDLE_RADIUS + 10, W / 2 - PADDLE_RADIUS - 10);
      const targetY = clamp(mousePos.y, PADDLE_RADIUS + 10, H - PADDLE_RADIUS - 10);

      const speedLimit = 16;
      const dx = targetX - player.x;
      const dy = targetY - player.y;
      const dist = Math.hypot(dx, dy);
      const maxStep = speedLimit;

      if (dist > maxStep) {
        const ratio = maxStep / dist;
        player.x += dx * ratio;
        player.y += dy * ratio;
      } else {
        player.x = targetX;
        player.y = targetY;
      }

      if (player.lastX == null) {
        player.lastX = player.x;
        player.lastY = player.y;
      }

      player.vx = player.x - player.lastX;
      player.vy = player.y - player.lastY;

      player.lastX = player.x;
      player.lastY = player.y;
    }

    function predictPuckYAtX(targetX) {
      let simX = puck.x;
      let simY = puck.y;
      let simVx = puck.vx;
      let simVy = puck.vy;

      for (let i = 0; i < 200; i++) {
        simX += simVx;
        simY += simVy;

        if (simY - PUCK_RADIUS < 10) {
          simY = 10 + PUCK_RADIUS;
          simVy *= -1;
        }
        if (simY + PUCK_RADIUS > H - 10) {
          simY = H - 10 - PUCK_RADIUS;
          simVy *= -1;
        }

        if (simX - PUCK_RADIUS < 10 || simX + PUCK_RADIUS > W - 10) {
          break;
        }

        if ((simVx > 0 && simX >= targetX && puck.vx > 0) ||
            (simVx < 0 && simX <= targetX && puck.vx < 0)) {
          return simY;
        }
      }
      return simY;
    }

    function updateAIPaddle() {
      const reactionZone = W * 0.4;
      const aiMaxSpeed = 10;

      let targetY = H / 2;

      if (puck.x > reactionZone && puck.vx > 0) {
        const predictedY = predictPuckYAtX(W * 0.72);
        targetY = clamp(predictedY, PADDLE_RADIUS + 10, H - PADDLE_RADIUS - 10);
      }

      let targetX;
      if (puck.vx > 0 && puck.x > W / 2) {
        targetX = W * 0.78;
      } else {
        targetX = W * 0.72;
      }

      const dx = targetX - ai.x;
      const dy = targetY - ai.y;
      const dist = Math.hypot(dx, dy);

      if (dist > 0) {
        const step = Math.min(aiMaxSpeed, dist);
        ai.x += (dx / dist) * step;
        ai.y += (dy / dist) * step;
      }

      ai.x = clamp(ai.x, W / 2 + PADDLE_RADIUS + 5, W - PADDLE_RADIUS - 10);
      ai.y = clamp(ai.y, PADDLE_RADIUS + 10, H - PADDLE_RADIUS - 10);
    }

    function reflectPuck(normalX, normalY, addBoost = 0) {
      const speedBefore = Math.hypot(puck.vx, puck.vy) || 1;

      const dot = puck.vx * normalX + puck.vy * normalY;
      puck.vx = puck.vx - 2 * dot * normalX;
      puck.vy = puck.vy - 2 * dot * normalY;

      let speedAfter = Math.hypot(puck.vx, puck.vy) + addBoost;
      const scale = Math.min(MAX_PUCK_SPEED, speedAfter) / (speedAfter || 1);
      puck.vx *= scale;
      puck.vy *= scale;

      puck.vx *= BOUNCE_DAMPING;
      puck.vy *= BOUNCE_DAMPING;
    }

    function handlePaddleCollision(paddle) {
      const dx = puck.x - paddle.x;
      const dy = puck.y - paddle.y;
      const dist = Math.hypot(dx, dy);
      const minDist = PUCK_RADIUS + paddle.radius;

      if (dist < minDist && dist > 0) {
        const overlap = minDist - dist;
        const nx = dx / dist;
        const ny = dy / dist;

        puck.x += nx * overlap;
        puck.y += ny * overlap;

        puck.vx += paddle.vx * 0.6;
        puck.vy += paddle.vy * 0.6;

        reflectPuck(nx, ny, 2.5);
      }
    }

    function physicsStep() {
      puck.x += puck.vx;
      puck.y += puck.vy;

      puck.vx *= FRICTION;
      puck.vy *= FRICTION;

      const speed = Math.hypot(puck.vx, puck.vy);
      if (speed > MAX_PUCK_SPEED) {
        const scale = MAX_PUCK_SPEED / speed;
        puck.vx *= scale;
        puck.vy *= scale;
      }

      if (puck.y - PUCK_RADIUS < 10) {
        puck.y = 10 + PUCK_RADIUS;
        reflectPuck(0, 1);
      }
      if (puck.y + PUCK_RADIUS > H - 10) {
        puck.y = H - 10 - PUCK_RADIUS;
        reflectPuck(0, -1);
      }

      const leftGoalX = 10;
      const rightGoalX = W - 10;

      if (puck.x - PUCK_RADIUS < leftGoalX) {
        if (puck.y > H / 2 - GOAL_WIDTH / 2 && puck.y < H / 2 + GOAL_WIDTH / 2) {
          aiScore++;
          updateScoreDisplay();
          if (aiScore >= WIN_SCORE) {
            statusEl.textContent = "AI wins! Resetting game...";
            setTimeout(resetGame, 1200);
          } else {
            resetRound("ai");
          }
          return;
        } else {
          puck.x = leftGoalX + PUCK_RADIUS;
          reflectPuck(1, 0);
        }
      }

      if (puck.x + PUCK_RADIUS > rightGoalX) {
        if (puck.y > H / 2 - GOAL_WIDTH / 2 && puck.y < H / 2 + GOAL_WIDTH / 2) {
          playerScore++;
          updateScoreDisplay();
          if (playerScore >= WIN_SCORE) {
            statusEl.textContent = "You win! Resetting game...";
            setTimeout(resetGame, 1200);
          } else {
            resetRound("player");
          }
          return;
        } else {
          puck.x = rightGoalX - PUCK_RADIUS;
          reflectPuck(-1, 0);
        }
      }

      handlePaddleCollision(player);
      handlePaddleCollision(ai);
    }

    function drawTable() {
      ctx.fillStyle = "#084057";
      ctx.fillRect(0, 0, W, H);

      ctx.strokeStyle = "#0da4d6";
      ctx.lineWidth = 4;
      ctx.strokeRect(10, 10, W - 20, H - 20);

      ctx.beginPath();
      ctx.moveTo(W / 2, 10);
      ctx.lineTo(W / 2, H - 10);
      ctx.strokeStyle = "rgba(255,255,255,0.3)";
      ctx.lineWidth = 2;
      ctx.setLineDash([10, 8]);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.beginPath();
      ctx.arc(W / 2, H / 2, 50, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = "#111";
      ctx.fillRect(10 - 2, H / 2 - GOAL_WIDTH / 2, 8, GOAL_WIDTH);
      ctx.fillRect(W - 10 - 6, H / 2 - GOAL_WIDTH / 2, 8, GOAL_WIDTH);
    }

    function drawPaddle(p, color) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius * 0.45, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(255,255,255,0.4)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function drawPuck() {
      ctx.beginPath();
      ctx.arc(puck.x, puck.y, PUCK_RADIUS, 0, Math.PI * 2);
      ctx.fillStyle = "#f5f5f5";
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(puck.x, puck.y, PUCK_RADIUS * 0.4, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(0,0,0,0.4)";
      ctx.lineWidth = 1.5;
      ctx.stroke();
    }

    function loop() {
      updatePlayerPaddle();
      updateAIPaddle();
      physicsStep();

      ctx.clearRect(0, 0, W, H);
      drawTable();
      drawPuck();
      drawPaddle(player, "#ffd34f");
      drawPaddle(ai, "#ff4f6a");

      requestAnimationFrame(loop);
    }

    resetGame();
    loop();
  </script>
</body>
</html>
